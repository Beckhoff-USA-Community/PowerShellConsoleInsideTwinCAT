<?xml version="1.0" encoding="utf-8"?>
<project xmlns="http://www.plcopen.org/xml/tc6_0200">
  <fileHeader companyName="Beckhoff Automation GmbH" productName="TwinCAT PLC Control" productVersion="3.5.13.21" creationDateTime="2023-04-28T08:28:43.108099" />
  <contentHeader name="TwinCAT_PowerShellExample" modificationDateTime="2023-04-28T08:28:43.1181092">
    <coordinateInfo>
      <fbd>
        <scaling x="1" y="1" />
      </fbd>
      <ld>
        <scaling x="1" y="1" />
      </ld>
      <sfc>
        <scaling x="1" y="1" />
      </sfc>
    </coordinateInfo>
    <addData>
      <data name="http://www.3s-software.com/plcopenxml/projectinformation" handleUnknown="implementation">
        <ProjectInformation />
      </data>
    </addData>
  </contentHeader>
  <types>
    <dataTypes />
    <pous>
      <pou name="FB_PowerShell" pouType="functionBlock">
        <interface>
          <outputVars>
            <variable name="udiErrId">
              <type>
                <UDINT />
              </type>
            </variable>
            <variable name="xBusy">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="xError">
              <type>
                <BOOL />
              </type>
            </variable>
          </outputVars>
          <localVars>
            <variable name="iStep">
              <type>
                <INT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">State machine</xhtml>
              </documentation>
            </variable>
            <variable name="iErrorCounter">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="TonRetryTimer">
              <type>
                <derived name="TON" />
              </type>
            </variable>
            <variable name="fbRenameFile">
              <type>
                <derived name="FB_FileRename" />
              </type>
            </variable>
            <variable name="fbFileDelete">
              <type>
                <derived name="FB_FileDelete" />
              </type>
            </variable>
            <variable name="fbFileOpen">
              <type>
                <derived name="FB_FileOpen" />
              </type>
            </variable>
            <variable name="fbFileClose">
              <type>
                <derived name="FB_FileClose" />
              </type>
            </variable>
            <variable name="fbFileTell">
              <type>
                <derived name="FB_FileTell" />
              </type>
            </variable>
            <variable name="fbFileWrite">
              <type>
                <derived name="FB_FileWrite" />
              </type>
            </variable>
            <variable name="hSrcFile">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="0" />
              </initialValue>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> file handle of the source file </xhtml>
              </documentation>
            </variable>
            <variable name="barrWriteBuffer">
              <type>
                <array>
                  <dimension lower="1" upper="udiBufferSize" />
                  <baseType>
                    <BYTE />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="udiWriteBufferAddPos">
              <type>
                <UDINT />
              </type>
              <initialValue>
                <simpleValue value="1" />
              </initialValue>
            </variable>
            <variable name="udiWriteBufferWritePos">
              <type>
                <UDINT />
              </type>
              <initialValue>
                <simpleValue value="1" />
              </initialValue>
            </variable>
            <variable name="udiWriteBufferWriteLength">
              <type>
                <UDINT />
              </type>
            </variable>
            <variable name="xFileHeaderNeeded">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="_sFileRoot">
              <type>
                <derived name="T_MAXSTRING" />
              </type>
            </variable>
            <variable name="nMode">
              <type>
                <DWORD />
              </type>
              <initialValue>
                <simpleValue value="FOPEN_MODEWRITE" />
              </initialValue>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">FOPEN_MODEAPPEND  OR FOPEN_MODETEXT;</xhtml>
              </documentation>
            </variable>
            <variable name="xBusyCreateDirEx">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> Create Dir Method</xhtml>
              </documentation>
            </variable>
            <variable name="xErrorCreateDirEx">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="udiErrorIdCreateDirEx">
              <type>
                <UDINT />
              </type>
            </variable>
            <variable name="xFileExist">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> End Create Dir Method
 File Exist Check Method</xhtml>
              </documentation>
            </variable>
            <variable name="xBusyFileExistCheck">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="xErrorFileExistCheck">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="udiInternalErrorIDFileExistCheck">
              <type>
                <UDINT />
              </type>
            </variable>
            <variable name="xFolderExist">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> End File Exist Check Method
 Folder Exist Check Method</xhtml>
              </documentation>
            </variable>
            <variable name="xBusyFolderExistCheck">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="xErrorFolderExistCheck">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="udiInternalErrorIDFolderExistCheck">
              <type>
                <UDINT />
              </type>
            </variable>
            <variable name="sPowerShellFileName">
              <type>
                <string />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">EndFolder Exist Check Method
File Write only stuff</xhtml>
              </documentation>
            </variable>
            <variable name="sPowerShellFileNamePartial_1">
              <type>
                <string />
              </type>
              <initialValue>
                <simpleValue value="'PowerShell'" />
              </initialValue>
            </variable>
            <variable name="sPowerShellFileNamePartial_2">
              <type>
                <string />
              </type>
            </variable>
            <variable name="sPowerShellFilePath">
              <type>
                <derived name="T_MAXSTRING" />
              </type>
            </variable>
            <variable name="iFileCounter">
              <type>
                <INT />
              </type>
              <initialValue>
                <simpleValue value="1" />
              </initialValue>
            </variable>
            <variable name="sFileRoot">
              <type>
                <string />
              </type>
              <initialValue>
                <simpleValue value="'C:\PowerShellCommands\'" />
              </initialValue>
            </variable>
            <variable name="sFileName">
              <type>
                <string />
              </type>
              <initialValue>
                <simpleValue value="'PowerShell.ps1'" />
              </initialValue>
            </variable>
            <variable name="sHeader">
              <type>
                <derived name="T_MaxString" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Header inside file. Ideal for CSV files that need column names</xhtml>
              </documentation>
            </variable>
            <variable name="sFileNameHistory">
              <type>
                <string />
              </type>
              <initialValue>
                <simpleValue value="'PowerShellold.ps1'" />
              </initialValue>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">If File exceeds 1 megabyte, file is renamed to this.</xhtml>
              </documentation>
            </variable>
            <variable name="fwBusy">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="BatchFileFullPath">
              <type>
                <string />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">End file write stuff
Powershell stuff</xhtml>
              </documentation>
            </variable>
            <variable name="FBStartProcess">
              <type>
                <derived name="NT_StartProcess" />
              </type>
            </variable>
            <variable name="psStep">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="bBlockAddingToPowerShell">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="barrWriteBufferPowerShell">
              <type>
                <array>
                  <dimension lower="1" upper="udiBufferSize" />
                  <baseType>
                    <BYTE />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="udiWriteBufferPowerShellAddPos">
              <type>
                <UDINT />
              </type>
              <initialValue>
                <simpleValue value="1" />
              </initialValue>
            </variable>
            <variable name="bBatchFileIsCreated">
              <type>
                <BOOL />
              </type>
            </variable>
          </localVars>
          <localVars constant="true">
            <variable name="udiBufferSize">
              <type>
                <UDINT />
              </type>
              <initialValue>
                <simpleValue value="100000" />
              </initialValue>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">(*
Wrote by Shawn Sidelinger
How this works:
Step 0: Buffer commands in a byte array.
Step 1: create powershell file with desired powershell code.
Step 2: create batch file to execute the powershell code.
Step 3: execute batch file which runs powershell code

Commands are buffered while the file write process is busy. Then executed in a new powershell file to reduce chances of an issue.
*)

CASE psStep OF
0:
	//Auto start writing powershell program when buffer has data.
	FileWriteSequence();
	
	IF (udiWriteBufferAddPos &lt;&gt; udiWriteBufferWritePos) THEN
		psStep:=psStep+10;
	ELSIF udiWriteBufferPowerShellAddPos &gt; 1 THEN
		M_LogData(ADR(barrWriteBufferPowerShell),udiWriteBufferPowerShellAddPos-1);		
		udiWriteBufferPowerShellAddPos:=1;//Reset pointer tracker.
	END_IF
	
	IF psStep &lt;&gt; 0 THEN
		sPowerShellFileNamePartial_2:=TO_STRING(iFileCounter);
		sPowerShellFileName:=CONCAT(CONCAT(sPowerShellFileNamePartial_1,sPowerShellFileNamePartial_2),'.ps1');
		sPowerShellFilePath:=CONCAT(sFileRoot,sPowerShellFileName);
		sFileName:= sPowerShellFileName;
	END_IF
	
	
10: //Wait for powershell file to be done being written.
	FileWriteSequence();
	IF NOT fwBusy AND NOT xError THEN	
		IF bBatchFileIsCreated THEN
			psStep:=psStep+20;
		ELSE
			psStep:=psStep+10;
			sFileName:= 'Batch.bat';
			BatchFileFullPath:=CONCAT(sFileRoot,sFileName);
			M_LogString('PowerShell.exe -executionpolicy remotesigned -File');//C:\TwinCAT\3.1\Target\Resource\VariantSwitch.ps1 %1');
			//M_LogString(sFileRoot);
			//M_LogString(sPowerShellFileName);
			M_LogString(' %1');
		END_IF
	ELSIF xError THEN
		psStep:=0;
	END_IF
	
20: //Wait for Batch file to be done being written.
	FileWriteSequence();
	IF NOT fwBusy AND NOT xError  THEN
		psStep:=psStep+10;
		bBatchFileIsCreated:=TRUE;
	ELSIF xError THEN
		psStep:=0;
	END_IF

	
30:
	FBStartProcess(NETID := '',	START :=FALSE);
	IF NOT fwBusy AND NOT FBStartProcess.BUSY THEN //Asume file is done being written
		psStep:=psStep+10;	
	END_IF
	
40:
	FBStartProcess(NETID := '',
		PATHSTR := BatchFileFullPath,
		DIRNAME := sFileRoot,
		COMNDLINE := sPowerShellFilePath,
		START :=TRUE ,
		TMOUT :=,
		BUSY =&gt; ,
		ERR =&gt;xError ,
		ERRID =&gt; udiErrId);
	IF NOT FBStartProcess.BUSY THEN //Asume file is done being written
		psStep:=0;
		iFileCounter:=iFileCounter+1;
		IF iFileCounter &gt; 10 THEN
			iFileCounter:=1;
		END_IF
	END_IF

END_CASE


xBusy:=psStep&lt;&gt;0;
bBlockAddingToPowerShell:=xBusy;


</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="AddPowerShellLine" ObjectId="7518d16a-c668-4dbd-ba42-cfc370e672af">
              <interface>
                <returnType>
                  <BOOL />
                </returnType>
                <inputVars>
                  <variable name="sCommand">
                    <type>
                      <derived name="T_MaxSTRING" />
                    </type>
                  </variable>
                </inputVars>
                <localVars>
                  <variable name="udiLength">
                    <type>
                      <UDINT />
                    </type>
                  </variable>
                  <variable name="sChar">
                    <type>
                      <string length="1" />
                    </type>
                  </variable>
                </localVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">IF NOT bBlockAddingToPowerShell THEN
	M_LogString(sCommand);
	M_LogAddChar('$r');//Add carriage return
	//M_LogAddChar('$l');//Add carriage return
ELSE
	//If the current program is executing commands and is busy, lets buffer the new commands to be executed later. 
	//Lot of code below, most of its copy and paste and overkill.
	IF DINT_TO_UDINT(LEN(sCommand)) + udiWriteBufferPowerShellAddPos - 1 &lt;= udiBufferSize THEN
		MEMCPY(	ADR(barrWriteBufferPowerShell[udiWriteBufferPowerShellAddPos]), ADR(sCommand),DINT_TO_UDINT(LEN(sCommand)));
		udiWriteBufferPowerShellAddPos:=udiWriteBufferPowerShellAddPos + DINT_TO_UDINT(LEN(sCommand));
		IF udiWriteBufferPowerShellAddPos &gt; udiBufferSize THEN
			udiWriteBufferPowerShellAddPos:=1;
		END_IF
	
	ELSE
		udiLength:=udiBufferSize -udiWriteBufferPowerShellAddPos + 1;
		MEMCPY(	ADR(barrWriteBufferPowerShell[udiWriteBufferPowerShellAddPos]), ADR(sCommand), udiLength);
		
		
		MEMCPY(	ADR(barrWriteBufferPowerShell[1]), ADR(sCommand)+udiLength ,DINT_TO_UDINT(LEN(sCommand))-udiLength);
		udiWriteBufferPowerShellAddPos:=udiWriteBufferPowerShellAddPos + DINT_TO_UDINT(LEN(sCommand)) -udiBufferSize ;
	
	END_IF
	sChar:='$r';
	MEMCPY(ADR(barrWriteBufferPowerShell[udiWriteBufferPowerShellAddPos]),ADR(sChar),1);
	IF  udiWriteBufferPowerShellAddPos &lt; udiBufferSize THEN
			udiWriteBufferPowerShellAddPos:=udiWriteBufferPowerShellAddPos +1;
	ELSE
			udiWriteBufferPowerShellAddPos:=1;
	END_IF
	(*sChar:='$l';
	MEMCPY(ADR(barrWriteBufferPowerShell[udiWriteBufferPowerShellAddPos]),ADR(sChar),1);
	IF  udiWriteBufferPowerShellAddPos &lt; udiBufferSize THEN
			udiWriteBufferPowerShellAddPos:=udiWriteBufferPowerShellAddPos +1;
	ELSE
			udiWriteBufferPowerShellAddPos:=1;
	END_IF*)
	
END_IF</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="FB_CreateDirEx" ObjectId="d4ae4041-8403-419b-896f-a8117fdf11ab">
              <interface>
                <returnType>
                  <BOOL />
                </returnType>
                <inputVars>
                  <variable name="sFileRoot">
                    <type>
                      <derived name="T_MAXSTRING" />
                    </type>
                  </variable>
                  <variable name="xExecute">
                    <type>
                      <BOOL />
                    </type>
                  </variable>
                </inputVars>
                <addData>
                  <data name="http://www.3s-software.com/plcopenxml/accessmodifiers" handleUnknown="implementation">
                    <AccessModifiers Internal="true" />
                  </data>
                  <data name="http://www.3s-software.com/plcopenxml/attributes" handleUnknown="implementation">
                    <Attributes>
                      <Attribute Name="hide" Value="" />
                    </Attributes>
                  </data>
                </addData>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">//This method was copied from a CreateDirEx function block so that the function block doesn't need to be included
TrigExecute(CLK:=xExecute);

CASE iStep OF
0:
	IF TrigExecute.Q THEN
		xErrorCreateDirEx := FALSE;
		udiErrorIdCreateDirEx:=0;
		iStep:=iStep+10;
		iDirectoryLevel:=2;
	ELSIF xExecute = FALSE THEN
		xErrorCreateDirEx := FALSE;
		udiErrorIdCreateDirEx:=0;
	END_IF
		

10:
	//First Find the "/" that matches the directory we want to check thate exist
	iLevelCount:=0;
	FOR x:=0 TO LEN(sFileRoot) BY 1 DO
		IF sFileRoot[x] = 92 THEN
			iLevelCount:=iLevelCount+1;
			IF iLevelCount = iDirectoryLevel THEN
				x:=x+1;
				EXIT;
			END_IF
		END_IF
	END_FOR
	iStartPos:=x;
	MEMCPY(ADR(sDirectoryToBeAdded),ADR(sFileRoot),iStartPos);
	MEMSet(ADR(sDirectoryToBeAdded)+iStartPos,0,1);

	FB_FolderExistCheck(xExecute:=FALSE , sPathName:= sDirectoryToBeAdded, xAbort:=FALSE);
	FB_FolderExistCheck(xExecute:=TRUE , sPathName:= sDirectoryToBeAdded, xAbort:=FALSE);
	iStep:=iStep+10;
	
20: //Check if directory is their
	FB_FolderExistCheck(xExecute:=TRUE , sPathName:= sDirectoryToBeAdded, xAbort:=FALSE);
	IF NOT xBusyFolderExistCheck THEN
		IF NOT xErrorFolderExistCheck THEN
			IF xFolderExist THEN
				IF sDirectoryToBeAdded = sFileRoot THEN
					iStep:=0; // Done
				ELSE
					iDirectoryLevel:=iDirectoryLevel+1;
					iStep:=10;
				END_IF
			ELSE
				iStep:=iStep+10;
			END_IF
		ELSE
			//Error
				udiErrorIdCreateDirEx := udiInternalErrorIDFolderExistCheck;
				iStep:=0;
				xErrorCreateDirEx := TRUE;
		END_IF
		FB_FolderExistCheck(xExecute:=FALSE, sPathName:= sDirectoryToBeAdded, xAbort:=FALSE );
	END_IF

30:	(*create directory *)
	fbCreateDir( bExecute := FALSE );
	fbCreateDir( 		sPathName:=sDirectoryToBeAdded,
					ePath:=PATH_GENERIC,
					bExecute:=TRUE,
					tTimeout:=T#1000ms );
	iStep := iStep + 10;


40:
	fbCreateDir(bExecute := FALSE);
	IF NOT fbCreateDir.bBusy THEN
		IF NOT fbCreateDir.bError THEN
			iStep := 10;
			iDirectoryLevel:=iDirectoryLevel+1;
		ELSE
			udiErrorIdCreateDirEx := fbCreateDir.nErrId;
			iStep:=0;
			xErrorCreateDirEx := TRUE;
		END_IF;
	END_IF
		
END_CASE

xBusyCreateDirEx:=iStep&lt;&gt;0;
</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="FB_FileExistCheck" ObjectId="657b7218-2c18-4317-ad12-2bcc592d4a77">
              <interface>
                <returnType>
                  <BOOL />
                </returnType>
                <inputVars>
                  <variable name="xExecute">
                    <type>
                      <BOOL />
                    </type>
                  </variable>
                  <variable name="sPathName">
                    <type>
                      <string />
                    </type>
                  </variable>
                  <variable name="xAbort">
                    <type>
                      <BOOL />
                    </type>
                  </variable>
                </inputVars>
                <addData>
                  <data name="http://www.3s-software.com/plcopenxml/accessmodifiers" handleUnknown="implementation">
                    <AccessModifiers Internal="true" />
                  </data>
                  <data name="http://www.3s-software.com/plcopenxml/attributes" handleUnknown="implementation">
                    <Attributes>
                      <Attribute Name="hide" Value="" />
                    </Attributes>
                  </data>
                </addData>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">TrigExecute(CLK:=xExecute);
CASE iState OF
0:
	IF TrigExecute.Q THEN (* flag set ? *)
		fbEnum.eCmd := eEnumCmd_First; (* enum first entry *)
		iState := 2;
		xFileExist:=FALSE;
		xErrorFileExistCheck:=FALSE;
		fbEnum( bExecute := FALSE );
		fbEnum( bExecute := TRUE, sPathName := sPathName);
	END_IF

1: (* enum one entry *)
	IF xAbort THEN
		fbEnum.eCmd := eEnumCmd_Abort;
	END_IF
	fbEnum( bExecute := FALSE );
	fbEnum( bExecute := TRUE, sPathName := sPathName);
	iState := 2;

2: (* wait until function block not busy *)
	fbEnum( bExecute := FALSE );
	IF NOT fbEnum.bBusy THEN
		IF NOT fbEnum.bError THEN
			IF NOT fbEnum.bEOE THEN
				(*Check for directory or file*)
				IF fbEnum.stFindFile.fileAttributes.bDirectory THEN
					iState:=1;
					fbEnum.eCmd := eEnumCmd_Next; (* enum next entry *)
				ELSE
					//Found file
					iState:=0;
					xFileExist:=TRUE;
				END_IF

			ELSE (* no more entries *)
				iState := 0;
			END_IF
		ELSE (* log error *)
			xErrorFileExistCheck:=TRUE;
			udiInternalErrorIDFileExistCheck:=fbEnum.nErrID;
			iState := 0;
		END_IF
	END_IF
END_CASE
IF iState = 0 THEN
	xBusyFileExistCheck:=FALSE;
ELSE
	xBusyFileExistCheck:=TRUE;
END_IF</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="FB_FolderExistCheck" ObjectId="68faa0ce-dc45-497b-ba6e-b739d81efea6">
              <interface>
                <returnType>
                  <BOOL />
                </returnType>
                <inputVars>
                  <variable name="xExecute">
                    <type>
                      <BOOL />
                    </type>
                  </variable>
                  <variable name="sPathName">
                    <type>
                      <string />
                    </type>
                  </variable>
                  <variable name="xAbort">
                    <type>
                      <BOOL />
                    </type>
                  </variable>
                </inputVars>
                <addData>
                  <data name="http://www.3s-software.com/plcopenxml/accessmodifiers" handleUnknown="implementation">
                    <AccessModifiers Internal="true" />
                  </data>
                  <data name="http://www.3s-software.com/plcopenxml/attributes" handleUnknown="implementation">
                    <Attributes>
                      <Attribute Name="hide" Value="" />
                    </Attributes>
                  </data>
                </addData>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">TrigExecute(CLK:=xExecute);
CASE iState OF
0:
	IF TrigExecute.Q THEN (* flag set ? *)
		fbEnum.eCmd := eEnumCmd_First; (* enum first entry *)
		iState := 1;
		xFolderExist:=FALSE;
		sPathSearchName := sPathName;
		// Remove \
		IF Len(sPathName) &gt; 0 THEN
			IF sPathSearchName[Len(sPathName)-1] = 92 THEN
				sPathSearchName[Len(sPathName)-1] := 0;
			END_IF
		
			//Get the Child Name
			FOR x:= INT_TO_UINT(LEN(sPathSearchName)-1) TO 0 BY -1 DO
					IF sPathSearchName[x] = 92  THEN
						IF INT_TO_UINT(LEN(sPathSearchName)) &gt; x THEN
							MEMCPY(ADR(sChildDirectory),ADR(sPathSearchName)+x+1,DINT_TO_UDINT(LEN(sPathSearchName))-x);
						END_IF
						EXIT;
					END_IF
			END_FOR
		END_IF
		xErrorFolderExistCheck:=FALSE;
	END_IF

1: (* enum one entry *)
	IF xAbort THEN
		fbEnum.eCmd := eEnumCmd_Abort;
	END_IF
	fbEnum( bExecute := FALSE );
	fbEnum( bExecute := TRUE, sPathName := sPathSearchName);
	iState := 2;

2: (* wait until function block not busy *)
	fbEnum( bExecute := FALSE );
	IF NOT fbEnum.bBusy THEN
		IF NOT fbEnum.bError THEN
			IF NOT fbEnum.bEOE THEN
				(*Check for directory or file*)
				IF fbEnum.stFindFile.fileAttributes.bDirectory THEN
					IF sChildDirectory = fbEnum.stFindFile.sFileName THEN
						xFolderExist:=TRUE;
						//Found file
						iState:=0;
					ELSE
						iState:=1;
						fbEnum.eCmd := eEnumCmd_Next; (* enum next entry *)
					END_IF
					
				ELSE
					iState:=1;
					fbEnum.eCmd := eEnumCmd_Next; (* enum next entry *)
					
				END_IF

			ELSE (* no more entries *)
				iState := 0;
			END_IF
		ELSE (* log error *)
			xErrorFolderExistCheck:=TRUE;
			udiInternalErrorIDFolderExistCheck:=fbEnum.nErrID;
			iState := 0;
		END_IF
	END_IF
END_CASE
IF iState = 0 THEN
	xBusyFolderExistCheck:=FALSE;
ELSE
	xBusyFolderExistCheck:=TRUE;
END_IF</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="FileWriteSequence" ObjectId="a0d70ce5-217b-4501-a69e-a9eba05c7ef0">
              <interface>
                <returnType>
                  <BOOL />
                </returnType>
                <addData>
                  <data name="http://www.3s-software.com/plcopenxml/attributes" handleUnknown="implementation">
                    <Attributes>
                      <Attribute Name="hide" Value="" />
                    </Attributes>
                  </data>
                </addData>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">//Features
// Log data at any speeds, even as fast as TwinCAT can run, 50us speeds. Data is buffered while hard drive is busy, then written.
// Auto Create Directory
// Auto rename file if it exceeds 1 mega byte in size
// Data can be CSV 
// Data can be any formate by using M_LogData or M_LogString
// Increase udiBufferSize if you are writing large amounts of data and notice missing data in file.
// Header is automaticly created as needed.

CASE iStep OF
	0:	(* idle wait for error message to log*)
		IF (udiWriteBufferAddPos &lt;&gt; udiWriteBufferWritePos) THEN
			_sFileRoot:=sFileRoot;
			IF _sFileRoot[Len(_sFileRoot)-1] &lt;&gt; 92 THEN
				_sFileRoot:=CONCAT(_sFileRoot,'\');
			END_IF 
			fwBusy := TRUE;
			udiErrId:=0;
			IF sHeader = '' THEN
				iStep := 10;
			ELSE
				iStep:=2;
			END_IF
		END_IF

	2: (*Check if file Exist, this state lets us know if the header needs to be added*)
		FB_FileExistCheck(xExecute:=FALSE , sPathName:=CONCAT(_sFileRoot, sFileName), xAbort:=FALSE  );
		FB_FileExistCheck(xExecute:=TRUE ,  sPathName:=CONCAT(_sFileRoot, sFileName), xAbort:=FALSE  );
		iStep:=4;
		
	4:
		FB_FileExistCheck(xExecute:=FALSE , sPathName:=CONCAT(_sFileRoot, sFileName), xAbort:=FALSE  );
		IF NOT xBusyFileExistCheck THEN
			IF NOT xErrorFileExistCheck THEN
				IF xFileExist THEN
					xFileHeaderNeeded:=FALSE;
				ELSE
					xFileHeaderNeeded:=TRUE;
				END_IF
				iStep:=10;
			ELSE
				udiErrId :=udiInternalErrorIDFileExistCheck;
				xError := TRUE;
				iStep:=1000;
			END_IF
		END_IF

	10:	(* open source file *)
		fbFileOpen(  bExecute := FALSE  );
		fbFileOpen( 		sPathName := CONCAT(_sFileRoot, sFileName),
						nMode := nMode,  (*FOPEN_MODETEXT  or FOPEN_MODEREAD or FOPEN_MODEWRITE *)
						ePath := PATH_GENERIC,
						tTimeout := T#1000ms,
						bExecute := TRUE );
		iStep := iStep + 10;


	20:
		fbFileOpen( bExecute := FALSE );
		IF ( NOT fbFileOpen.bBusy ) THEN
			IF ( fbFileOpen.bError ) THEN
				IF fbFileOpen.nErrId = 1804 THEN //This occurs when the folder does not exist.
					iStep:=300;
				ELSE
					udiErrId :=fbFileOpen.nErrId;
					xError := TRUE;
					iStep:=1000;
				END_IF
			ELSE
				hSrcFile := fbFileOpen.hFile;
				IF NOT xFileHeaderNeeded THEN
					iStep := iStep + 10;
				ELSE 
					iStep:=iStep+2;
				END_IF
			END_IF
		END_IF
		
	22: (*Header needed*)
		fbFileWrite(bExecute := FALSE);
		fbFileWrite(pWriteBuff:=ADR(sHeader),
			cbWriteLen:=DINT_TO_UDINT(LEN(sHeader)),
			hFile:=hSrcFile,
			tTimeout := T#1000ms,
			bExecute := TRUE );
		iStep:=iStep+2;

	24:
		fbFileWrite(bExecute := FALSE);
		IF ( NOT fbFileWrite.bBusy ) THEN
			IF ( fbFileWrite.bError ) THEN
				udiErrId :=fbFileWrite.nErrId;
				xError := TRUE;
				iStep:=1000;
			ELSE
				iStep := iStep+6;
			END_IF
		END_IF
				
	30:	(* Write to Source File *)
		IF udiWriteBufferAddPos &gt; udiWriteBufferWritePos THEN
			udiWriteBufferWriteLength:=udiWriteBufferAddPos - udiWriteBufferWritePos;
			
			fbFileWrite(  bExecute := FALSE  );
			fbFileWrite( 		pWriteBuff:=ADR(barrWriteBuffer[udiWriteBufferWritePos]),
				cbWriteLen:=udiWriteBufferWriteLength,
				hFile:=hSrcFile,
				tTimeout := T#1000ms,
				bExecute := TRUE );
			
			udiWriteBufferWritePos:=udiWriteBufferAddPos;
		
		ELSE
			udiWriteBufferWriteLength:=udiBufferSize - udiWriteBufferWritePos+1;
			
			fbFileWrite(  bExecute := FALSE  );
			fbFileWrite( 		pWriteBuff:=ADR(barrWriteBuffer[udiWriteBufferWritePos]),
				cbWriteLen:=udiWriteBufferWriteLength,
				hFile:=hSrcFile,
				tTimeout := T#1000ms,
				bExecute := TRUE );
			
			udiWriteBufferWritePos:=1;			
		END_IF
		iStep:=iStep+10;

	40:
		fbFileWrite(bExecute := FALSE);
		IF ( NOT fbFileWrite.bBusy ) THEN
			IF ( fbFileWrite.bError ) THEN
				udiErrId :=fbFileWrite.nErrId;
				xError := TRUE;
				iStep:=1000;
			ELSE
				IF udiWriteBufferAddPos = udiWriteBufferWritePos THEN
					iStep := iStep+10;
				ELSE
					iStep:=iStep-10;
				END_IF
			END_IF
		END_IF

	50:	(*Get File data Size information*)
		fbFileTell(  bExecute := FALSE  );
		fbFileTell( 		hFile:=hSrcFile,
						tTimeout := T#1000ms,
						bExecute := TRUE );
		iStep:=iStep+10;


	60:
		fbFileTell(bExecute := FALSE);
		IF ( NOT fbFileTell.bBusy ) THEN
			IF NOT fbFileTell.bError THEN
				iStep := iStep+10;
			ELSE
				udiErrId :=fbFileTell.nErrId;
				xError := TRUE;
				iStep:=1000;
			END_IF
		END_IF


	70: (* close source file *)
		fbFileClose( bExecute := FALSE );
		fbFileClose( 		hFile:=hSrcFile,
						bExecute:=TRUE,
						tTimeout:=T#1000ms );
		iStep := iStep + 10;


	80:
		fbFileClose(bExecute := FALSE);
		IF ( NOT fbFileClose.bBusy ) THEN
			IF ( fbFileClose.bError ) THEN
				udiErrId :=fbFileTell.nErrId;
				xError := TRUE;
				iStep:=1000;
				hSrcFile:=0;
			ELSE
				hSrcFile := 0;
				IF fbFileTell.nSeekPos &gt; 990000 THEN	(*If file is approaching 1 MB then lets start with a new log file*)
					iStep:=200;
				ELSE
					iStep := iStep+10;
				END_IF;
			END_IF;
		END_IF

	90: (*Finished, reset*)
		xError:=FALSE;
		fwBusy:=FALSE;
		iStep:=0;

	200:	(* Delete the last file*)
		fbFileDelete(  bExecute := FALSE  );
		fbFileDelete( 		sPathName :=CONCAT(_sFileRoot,sFileNameHistory),
						ePath := PATH_GENERIC,
						tTimeout := T#1000ms,
						bExecute := TRUE );
		iStep := iStep + 10;


	210:
		fbFileDelete( bExecute := FALSE );
		IF ( NOT fbFileDelete.bBusy ) THEN
			(*IF ( fbFileDelete.bError ) THEN (*ignore errors since this is expected*)
				udiErrId := fbFileOpen.nErrId;
				Step := 50;	
			ELSE*)
				iStep := iStep + 10;
			(*END_IF*)
		END_IF;

	220:	(* rename files so that the new data has a lower file number and older data has a larger file number*)
		fbRenameFile(  bExecute := FALSE  );
		fbRenameFile( 	sOldName:=CONCAT(_sFileRoot,sFileName),
						sNewName:=CONCAT(_sFileRoot,sFileNameHistory),
						ePath := PATH_GENERIC,
						tTimeout := T#1000ms,
						bExecute := TRUE );
		iStep := iStep + 10;

	230:
		fbRenameFile( bExecute := FALSE );
		IF ( NOT fbRenameFile.bBusy ) THEN
			(*IF ( fbRenameFile.bError ) THEN (*ignore errors since this is expected*)
				udiErrId := fbRenameFile.nErrId;
				Step := 50;	
			ELSE*)

				iStep := 90;

			(*END_IF*)
		END_IF;


	300:	(*create directory *)
		FB_CreateDirEx(sFileRoot:=_sFileRoot, xExecute := FALSE );
		FB_CreateDirEx( 		sFileRoot:=_sFileRoot,	xExecute:=TRUE );
		iStep := iStep + 10;


	310:
		FB_CreateDirEx(sFileRoot:=_sFileRoot,xExecute := FALSE);
		IF NOT xBusyCreateDirEx THEN
			IF NOT xErrorCreateDirEx THEN
				iStep := 10;
			ELSE
				udiErrId := udiErrorIdCreateDirEx;
				iStep:=1000;
				xError := TRUE;
				hSrcFile := 0;
			END_IF;
		END_IF

	1000: (*error *)
		IF (hSrcFile &lt;&gt; 0 ) THEN
			iStep := 70; (* close the source file *)
		ELSE
			TonRetryTimer(IN:=TRUE, PT:=T#5S);
			IF TonRetryTimer.Q THEN
				TonRetryTimer(IN:=FALSE);
				iStep := 0;	(* ready *)
				fwBusy := FALSE;
			END_IF
		END_IF

	1001:(*Log shutdown*)
			TonRetryTimer(IN:=TRUE, PT:=T#2h);
			IF TonRetryTimer.Q THEN
				TonRetryTimer(IN:=FALSE);
				iStep := 0;	(* ready *)
				fwBusy := FALSE;
				iErrorCounter:=0;
			END_IF

END_CASE</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="M_LogAddChar" ObjectId="7fba833b-394a-4a70-94bc-8ea30fcd472f">
              <interface>
                <returnType>
                  <BOOL />
                </returnType>
                <inputVars>
                  <variable name="sChar">
                    <type>
                      <string length="1" />
                    </type>
                  </variable>
                </inputVars>
                <addData>
                  <data name="http://www.3s-software.com/plcopenxml/accessmodifiers" handleUnknown="implementation">
                    <AccessModifiers Internal="true" />
                  </data>
                  <data name="http://www.3s-software.com/plcopenxml/attributes" handleUnknown="implementation">
                    <Attributes>
                      <Attribute Name="hide" Value="" />
                      <Attribute Name="object_name" Value="M_LogAddChar" />
                    </Attributes>
                  </data>
                </addData>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">//Use this to add a single Char to the log file. Great for adding comma's or carriage returns or Line feeds.

MEMCPY(ADR(barrWriteBuffer[udiWriteBufferAddPos]),ADR(sChar),1);
IF  udiWriteBufferAddPos &lt; udiBufferSize THEN
		udiWriteBufferAddPos:=udiWriteBufferAddPos +1;
ELSE
		udiWriteBufferAddPos:=1;
END_IF</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="M_LogAddColumn" ObjectId="c9bd7953-8246-43cb-a17b-0550e81a1a54">
              <interface>
                <returnType>
                  <BOOL />
                </returnType>
                <inputVars>
                  <variable name="sColumn">
                    <type>
                      <derived name="T_maxString" />
                    </type>
                  </variable>
                </inputVars>
                <localVars>
                  <variable name="udiLength">
                    <type>
                      <UDINT />
                    </type>
                  </variable>
                </localVars>
                <addData>
                  <data name="http://www.3s-software.com/plcopenxml/accessmodifiers" handleUnknown="implementation">
                    <AccessModifiers Internal="true" />
                  </data>
                  <data name="http://www.3s-software.com/plcopenxml/attributes" handleUnknown="implementation">
                    <Attributes>
                      <Attribute Name="hide" Value="" />
                      <Attribute Name="object_name" Value="M_LogAddColumn" />
                    </Attributes>
                  </data>
                </addData>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">
IF DINT_TO_UDINT(LEN(sColumn)) + udiWriteBufferAddPos - 1 &lt;= udiBufferSize THEN
	MEMCPY(	ADR(barrWriteBuffer[udiWriteBufferAddPos]), ADR(sColumn),DINT_TO_UDINT(LEN(sColumn)));
	udiWriteBufferAddPos:=udiWriteBufferAddPos + DINT_TO_UDINT(LEN(sColumn));
	IF udiWriteBufferAddPos &gt; udiBufferSize THEN
		udiWriteBufferAddPos:=1;
	END_IF

ELSE
	udiLength:=udiBufferSize -udiWriteBufferAddPos + 1;
	MEMCPY(	ADR(barrWriteBuffer[udiWriteBufferAddPos]), ADR(sColumn), udiLength);
	
	
	MEMCPY(	ADR(barrWriteBuffer[1]), ADR(sColumn)+udiLength ,DINT_TO_UDINT(LEN(sColumn))-udiLength);
	udiWriteBufferAddPos:=udiWriteBufferAddPos + DINT_TO_UDINT(LEN(sColumn)) -udiBufferSize ;

END_IF</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="M_LogData" ObjectId="63e9a47b-9638-4372-aade-b47f7344e125">
              <interface>
                <inputVars>
                  <variable name="pData">
                    <type>
                      <pointer>
                        <baseType>
                          <BYTE />
                        </baseType>
                      </pointer>
                    </type>
                  </variable>
                  <variable name="udiDataLength">
                    <type>
                      <UDINT />
                    </type>
                  </variable>
                </inputVars>
                <addData>
                  <data name="http://www.3s-software.com/plcopenxml/attributes" handleUnknown="implementation">
                    <Attributes>
                      <Attribute Name="hide" Value="" />
                      <Attribute Name="object_name" Value="M_LogData" />
                    </Attributes>
                  </data>
                </addData>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">//This method can be used to Log Raw data of any type and any formate. Pass in a pointer and the number of bytes you wish to record. A carriage return is NOT added to this.

IF pData &lt;&gt; 0 THEN
	IF udiDataLength + udiWriteBufferAddPos - 1 &lt;= udiBufferSize THEN
		MEMCPY(	ADR(barrWriteBuffer[udiWriteBufferAddPos]), pData,udiDataLength);
		udiWriteBufferAddPos:=udiWriteBufferAddPos +udiDataLength;
		IF udiWriteBufferAddPos &gt; udiBufferSize THEN
			udiWriteBufferAddPos:=1;
		END_IF
	
	ELSE
		(*Note how to calcuate initial write length -&gt; udiLength:=udiBufferSize -udiWriteBufferAddPos + 1;*)
		MEMCPY(	ADR(barrWriteBuffer[udiWriteBufferAddPos]), pData, (udiBufferSize -udiWriteBufferAddPos + 1));
	
		MEMCPY(	ADR(barrWriteBuffer[1]), pData+(udiBufferSize -udiWriteBufferAddPos + 1) ,udiDataLength - (udiBufferSize -udiWriteBufferAddPos + 1));
		udiWriteBufferAddPos:=udiWriteBufferAddPos + udiDataLength -udiBufferSize ;

	END_IF
END_IF</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="M_LogString" ObjectId="f5fc78de-e433-4ce1-b61e-f452f6618373">
              <interface>
                <inputVars>
                  <variable name="sColumn">
                    <type>
                      <derived name="T_maxString" />
                    </type>
                  </variable>
                </inputVars>
                <addData>
                  <data name="http://www.3s-software.com/plcopenxml/attributes" handleUnknown="implementation">
                    <Attributes>
                      <Attribute Name="hide" Value="" />
                      <Attribute Name="object_name" Value="M_LogString" />
                    </Attributes>
                  </data>
                </addData>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">//Will add a string, will not place a comma or a carriage return.
M_LogAddColumn(sColumn);

</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/property" handleUnknown="implementation">
            <Property name="PowerShellLine" ObjectId="a4ace6ce-e6ad-402b-9a8b-8c762f4b48f1">
              <interface>
                <returnType>
                  <derived name="T_MAXSTRING" />
                </returnType>
              </interface>
              <SetAccessor>
                <interface />
                <body>
                  <ST>
                    <xhtml xmlns="http://www.w3.org/1999/xhtml">AddPowerShellLine(PowerShellLine);</xhtml>
                  </ST>
                </body>
                <addData />
              </SetAccessor>
              <addData />
            </Property>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>c3a664cd-81aa-4e13-8e80-224ebd0401a3</ObjectId>
          </data>
        </addData>
      </pou>
    </pous>
  </types>
  <instances>
    <configurations />
  </instances>
  <addData>
    <data name="http://www.3s-software.com/plcopenxml/projectstructure" handleUnknown="discard">
      <ProjectStructure>
        <Object Name="FB_PowerShell" ObjectId="c3a664cd-81aa-4e13-8e80-224ebd0401a3">
          <Object Name="AddPowerShellLine" ObjectId="7518d16a-c668-4dbd-ba42-cfc370e672af" />
          <Object Name="FB_CreateDirEx" ObjectId="d4ae4041-8403-419b-896f-a8117fdf11ab" />
          <Object Name="FB_FileExistCheck" ObjectId="657b7218-2c18-4317-ad12-2bcc592d4a77" />
          <Object Name="FB_FolderExistCheck" ObjectId="68faa0ce-dc45-497b-ba6e-b739d81efea6" />
          <Object Name="FileWriteSequence" ObjectId="a0d70ce5-217b-4501-a69e-a9eba05c7ef0" />
          <Object Name="M_LogAddChar" ObjectId="7fba833b-394a-4a70-94bc-8ea30fcd472f" />
          <Object Name="M_LogAddColumn" ObjectId="c9bd7953-8246-43cb-a17b-0550e81a1a54" />
          <Object Name="M_LogData" ObjectId="63e9a47b-9638-4372-aade-b47f7344e125" />
          <Object Name="M_LogString" ObjectId="f5fc78de-e433-4ce1-b61e-f452f6618373" />
          <Object Name="PowerShellLine" ObjectId="a4ace6ce-e6ad-402b-9a8b-8c762f4b48f1" />
        </Object>
      </ProjectStructure>
    </data>
  </addData>
</project>